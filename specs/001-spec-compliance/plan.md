# Implementation Plan: WebSocket Message Contract Compliance

**Branch**: `001-spec-compliance` | **Date**: 2026-02-04 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-spec-compliance/spec.md`

## Summary

Fix WebSocket message contract to achieve 100% compliance with official TnT POC specification by adding BaseMessage fields (messageId, timestamp), standardizing on `payload` wrapper, enhancing transcript segments with tracking IDs and call-relative timing, adding call session tracking via callId, and correcting WebSocket path to `/tnt`.

## Technical Context

**Language/Version**: TypeScript 5.3 (frontend + backend)
**Primary Dependencies**: React 18.x, Zustand 4.x, ws 8.x, Tauri v2.x  
**Storage**: JSON logs (interactions.jsonl)
**Testing**: Manual validation via DevTools + WebSocket message inspection
**Target Platform**: Browser (Vite dev server port 1420) + Tauri desktop (Windows/Linux/macOS)
**Project Type**: Web application (React frontend + Node.js backend)
**Performance Goals**: No degradation from current POC performance  
**Constraints**: Zero breaking changes to existing functionality, maintain component swappability
**Scale/Scope**: POC-level (single user, mock backend, ~10 React components)

## Constitution Check

*No constitution.md file present - skipping gate check*

## Project Structure

### Documentation (this feature)

```text
specs/001-spec-compliance/
├── spec.md              # Feature specification (created)
├── plan.md              # This file
├── tasks.md             # Generated by /speckit.tasks
└── checklists/          # Quality validation checklists
    └── requirements.md
```

### Source Code (repository root)

```text
# Frontend (React + TypeScript)
src/
├── types/
│   └── messages.ts          # MODIFY: Add BaseMessage, change data→payload
├── hooks/
│   └── useWebSocket.ts      # MODIFY: Add messageId/timestamp generation
├── store/
│   └── callStore.ts         # MODIFY: Update to handle new fields
└── components/
    └── stitch/
        ├── TranscriptPanel.tsx  # MODIFY: Use startTime if displaying timeline
        └── (other components - minimal/no changes)

# Backend (Node.js + TypeScript)
backend/
├── src/
│   ├── types.ts             # MODIFY: Mirror frontend type changes
│   ├── server.ts            # MODIFY: Generate IDs/timestamps, update handlers
│   └── mockConversation.ts  # MODIFY: Generate segmentId, startTime, endTime
└── logs/
    └── interactions.jsonl   # No changes (logging format unchanged)

# Tauri (Rust)
src-tauri/
└── (no changes required)

# Documentation
docs/
├── component-replacement-guide.md  # UPDATE: Note message structure changes
└── demo-runbook.md                 # VERIFY: Still works after changes

.github/
└── copilot-instructions.md  # UPDATE: Document new message contract
```

## Phase 0: Research & Decisions

**Objective**: Resolve any technical unknowns and document decisions.

### Research Tasks

None required - all technical decisions already made:
- **UUID Generation**: Use `crypto.randomUUID()` (available in Node 16.7+, all modern browsers)
- **ISO 8601 Timestamps**: Use `new Date().toISOString()`
- **Payload Wrapper**: Standardize on `payload` (per spec)
- **AudioStatus**: Keep current structure (both channels) - documented deviation

### Deliverable

Create `research.md` documenting above decisions with rationale.

## Phase 1: Design & Contracts

**Objective**: Define data models and message contracts.

### Data Model

Create `data-model.md` with:

**BaseMessage** (all messages):
- messageId: UUID string
- timestamp: ISO 8601 string  
- type: message type discriminator

**TranscriptSegmentPayload**:
- segmentId: UUID string (unique per segment)
- speaker: 'caller' | 'telecommunicator'
- text: string
- isFinal: boolean
- startTime: number (seconds since call start)
- endTime?: number (only when isFinal=true)

**CallStatePayload**:
- state: 'idle' | 'connecting' | 'active' | 'ended'
- callId?: UUID string (present when state is 'active' or 'ended')

### Message Contracts

Create `contracts/websocket-messages.md` with:

**Frontend → Backend**:
```typescript
{
  type: 'call:start',
  messageId: 'uuid-string',
  timestamp: '2026-02-04T22:00:00.000Z'
}
```

**Backend → Frontend**:
```typescript
{
  type: 'transcript:segment',
  messageId: 'uuid-string',
  timestamp: '2026-02-04T22:00:05.123Z',
  payload: {
    segmentId: 'uuid-string',
    speaker: 'caller',
    text: 'Hola',
    isFinal: false,
    startTime: 5.123
  }
}
```

(Full contract examples for all 6 message types)

### Quick Start Guide

Create `quickstart.md` with:
- How to validate message structure using DevTools
- How to check messageId uniqueness
- How to verify ISO 8601 timestamp format
- How to test each user story independently

### Deliverables

- data-model.md
- contracts/websocket-messages.md
- quickstart.md

## Phase 2: Tasks Generation

Use `/speckit.tasks` to generate actionable task checklist in `tasks.md`.

## Implementation Strategy

**MVP**: User Story 1 (BaseMessage Foundation) - delivers message tracking immediately
**Incremental**: Each user story can be implemented and tested independently
**No Breaking Changes**: All changes are additive or renaming; functionality preserved
**Validation**: Manual testing via DevTools after each story completion

## Dependencies

- User Story 1 (BaseMessage) → Blocks all other stories (foundation)
- User Story 2 (Transcript) → Independent (can be done after US1)
- User Story 3 (CallId) → Independent (can be done after US1)
- User Story 4 (Path) → Independent (can be done anytime)

## Notes

- AudioStatus structure NOT changed (documented deviation from spec)
- Port 1420 kept (Tauri default, not spec's 5173)  
- No automated tests required (POC scope, manual validation sufficient)
- All changes must pass TypeScript compilation
- Demo runbook must work identically after changes
